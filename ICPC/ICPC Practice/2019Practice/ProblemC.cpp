#include <iostream>
#include <vector>
#include <string>
using namespace std;

vector<string> split(const string& input, char c)
{
    vector<string> out;
    string temp="";
    for(int i=0;input[i];i++)
    {
        if(input[i]==c)
        {
            out.push_back(temp);
            temp = "";
        }
        else
        {
            temp.push_back(input[i]);
            if(input[i+1]==0)
            {
                out.push_back(temp);
            }
        }
    }
    return out;
}

class Move
{
public:
    bool simple = false;
    vector<int> locations = vector<int>();
    Move(string mv):simple(false)
    {
        vector<string> locationsStr = vector<string>();
        if (int(mv.find('x'))==-1)
        {
            simple = true;
            locationsStr = split(mv, '-');
        }
        else
        {
            locationsStr = split(mv, 'x');
        }
        for(int i=0;i<locationsStr.size();i++)
        {
            locations.push_back(stoi(locationsStr[i]));
        }
    }
};

int getAdj(int loc, int mode)//mode 1 = top left, mode 2 = top right, mode 3 = bot left, mode 4 = bot right
{
    int rowNumber = (loc-1)/4;
    int out=-1;
    if (rowNumber%2==0)
    {
        if (mode == 1){out = loc-4;}
        else if(mode==2){out = loc-3;}
        else if(mode==3){out = loc+4;}
        else if(mode==4){out = loc+5;}
    }
    else
    {
        if (mode == 1){out = loc-5;}
        else if(mode==2){out = loc-4;}
        else if(mode==3){out = loc+3;}
        else if(mode==4){out = loc+4;}
    }
    if(out<0 || out > 32){cout<<"Incorrect value generated by getAdj()\n";}
    return out;
}

int getMid(int loc1, int loc2)//get middle location of two locations
{
    if (loc1>loc2)
    {
        int temp = loc1;
        loc1 = loc2;
        loc2 = temp;
    }
    // cout<<getAdj(loc1, 3)<<" "<<getAdj(loc2, 2)<<" "<<getAdj(loc2, 1)<<" "<<getAdj(loc1, 4)<<endl;
    if(getAdj(loc1, 3) == getAdj(loc2, 2)){return getAdj(loc1, 3);}
    else if(getAdj(loc1, 4) == getAdj(loc2, 1)){return getAdj(loc1, 4);}
    else 
    {
        cout<<"Incoorrect value generated by getMid()\n";
        return -1;
    }
}

bool checkPossible(int startLoc, int endLoc, bool black = true) //Check if a move is possible for a normal pawn
{
    if(black && endLoc<startLoc){return false;}
    else if(!black && startLoc<endLoc){return false;}
    else{return true;}
}

void printBoards(const vector<char>& board1, const vector<char>& board2)
{
    for(int i=0;i<8;i++)
    {
        for(int j=0;j<4;j++)
        {
            if(i%2==0){cout<<"-";}
            cout<<board1[i*4+j];
            if(i%2){cout<<"-";}
        }
        cout<<" ";
        for(int j=0;j<4;j++)
        {
            if(i%2==0){cout<<"-";}
            cout<<board2[i*4+j];
            if(i%2){cout<<"-";}
        }
        cout<<endl;
    }
}

int main()
{
    vector<char> board(32, '.');
    vector<Move> moves;
    char firstMove;
    int movesCount;
    cin>>firstMove>>movesCount;
    string temp;
    for(int i=0;i<movesCount;i++)
    {
        cin>>temp;
        moves.push_back(Move(temp));
    }
    bool black = firstMove=='B';
    if(movesCount%2==0){black = !black;}
    for(auto iter= moves.rbegin();iter!=moves.rend();iter++)
    {
        if(iter->simple)
        {
            if (board[iter->locations[1]-1]=='.')
            {
                board[iter->locations[0]-1] = black?'b':'w';
            }
            else
            {
                board[iter->locations[0]-1] = board[iter->locations[1]-1];
            }
            board[iter->locations[1]-1] = '.';
            if(!checkPossible(iter->locations[0],iter->locations[1],black))
            {
                board[iter->locations[0]-1] = black?'B':'W';
            }
        }
        else
        {
            for(int i=iter->locations.size()-1;i>0;i--)
            {
                int secondLoc = iter->locations[i];
                int firstLoc = iter->locations[i-1];
                board[getMid(firstLoc, secondLoc)-1] = black?'w':'b';
                if(board[secondLoc-1]=='.')
                {
                    board[firstLoc-1] = black?'b':'w';
                }
                else
                {
                    board[firstLoc-1] = board[secondLoc-1];
                    board[secondLoc-1] = '.';
                }
                if(!checkPossible(iter->locations[i-1],iter->locations[i],black))
                {
                    board[iter->locations[i-1]-1] = black?'B':'W';
                }
            }
        }
        black = !black;
    }
    vector<char> new_board = board;
    for(int i=0;i<moves.size();i++)
    {
        if(moves[i].simple)
        {
            new_board[moves[i].locations[1]-1] = new_board[moves[i].locations[0]-1];
            new_board[moves[i].locations[0]-1] = '.';
        }
        else
        {
            for(int j=0;j<moves[i].locations.size()-1;j++)
            {
                new_board[getMid(moves[i].locations[j+1],moves[i].locations[j])-1] = '.';
                new_board[moves[i].locations[j+1]-1] = new_board[moves[i].locations[j]-1];
                new_board[moves[i].locations[j]-1] = '.';     
            }
        }
    }
    printBoards(board, new_board);

    return 0;
}